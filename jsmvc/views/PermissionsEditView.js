/* View for editing Permissions.
* Renders a compiled template using doT.js
* Usage:    Get current selected permission level by calling getPermissions
*           Set selected permissions when calling the render function or by calling setPermissions.
*           In your views render:
*               Append this $el generated by this classes render function.
*/
var PermissionEditView = Backbone.View.extend({

    viewData: {},
    standardPermissions: true,
    changedRights: [],
    lastRight: {},
    multiSelectUserIds: [],
    multiSelectRoleIds: [],
    events: {
        'change input[type="checkbox"]': 'permissionsChanged'
    },
    /* 
        Calculates the current permission level, returns a long
    */
    getPermissions: function () {
        var permission = 0;
        this.$el.find('input[type="checkbox"] ').each(function () {
            if ($(this).is(':checked') === true) {
                permission = Utility.longOr(Number($(this).val()), permission);
            }
        });
        return permission;
    },
    /* Updates the checkboxes to match the passed in permission level.
    *  The permission level passed in should be a long.
    */
    setPermissions: function (permissionLevel) {
        var $el = this.$el;
        permissionLevel = Number(permissionLevel);
        _.each(this.viewData.dictionary, function (num, key) {
            if (Utility.hasFlag(permissionLevel, num )) {
                $el.find('input[name="' + key + '"]').prop("checked", true);
            }
            else {
                $el.find('input[name="' + key + '"]').prop("checked", false);
            }
        });
    },
    /*  Tracks any permission changes. If a change is detected it is added to an array that can be accessed on a commit.
    *   changedPermissions is an object modeled after ChangedPermissionDTO. It is stored in the array along with its new permission value.
    *   reset is a bool and if true will clear the array and lastRight.    
    *   multiSelUserIds / multiSelRoleIds is an array of additional ids that will receive the same permissions as the primary sent in. This is useful in a multiselect setup.
    */
    setTrackablePermissions: function (changedPermissions, reset, multiSelUserIds, multiSelRoleIds) {
        if (multiSelUserIds === undefined) { multiSelUserIds = []; }
        if (multiSelRoleIds === undefined) { multiSelRoleIds = []; }

        this.trackPermissionChanges(reset);
        this.setPermissions(changedPermissions.Permission);
        this.lastRight = _.clone(changedPermissions);
        if (changedPermissions.isUser) {
            multiSelUserIds.push(changedPermissions.UserRoleId);
        }
        else {
            multiSelRoleIds.push(changedPermissions.UserRoleId);
        }
        this.multiSelectUserIds = multiSelUserIds;
        this.multiSelectRoleIds = multiSelRoleIds;

    },
    /*  Returns all detected permission changes since last reset. 
    *   The return type can be sent to our rest api as a List<ChangedPermissionDTO>
    */
    getTrackablePermissions: function () {
        this.trackPermissionChanges(false);
        return this.changedRights;
    },
    trackPermissionChanges: function (reset) {
        var that = this;
        var permissions = this.getPermissions();

        if (Boolean(reset) === true) {
            this.changedRights = [];
            this.lastRight = {};
        }

        if ($.isEmptyObject(this.lastRight) === false) {
            if ((this.multiSelectUserIds.length > 1 || this.multiSelectRoleIds.length > 1) || this.lastRight.Permission !== permissions) {

                _.each(this.multiSelectUserIds, function (id) {
                    var changedRight = that.getCachedPermission(id);
                    if (changedRight === undefined) {
                        changedRight = _.clone(that.lastRight);
                        changedRight.UserRoleId = id;
                        changedRight.isUser = true;
                        that.changedRights.push(changedRight);
                    }
                    changedRight.Permission = permissions;
                });
                _.each(this.multiSelectRoleIds, function (id) {
                    var changedRight = that.getCachedPermission(id);
                    if (changedRight === undefined) {
                        changedRight = _.clone(that.lastRight);
                        changedRight.UserRoleId = id;
                        changedRight.isUser = false;
                        that.changedRights.push(changedRight);
                    }
                    changedRight.Permission = permissions;
                });
            }
        }
    },
    /*  Returns a cached (tracked change) ChangedPermissionDTO
    */
    getCachedPermission: function (userRoleId) {
        var cachedPermission = _.detect(this.changedRights, function (cr) { return cr.UserRoleId === userRoleId; });
        return cachedPermission;
    },
    /*
    * handleErrors - function to handle dressing multiple errors at a time
    * @param model - actual model with data
    * @param error - object with input names and corresponding error messages. 
    */
    handleErrors: function (model, error) {
        var errors = {};
        if (error.statusText === undefined) {
            errors.ct_Error = error;
        }
        else {
            errors.ct_Error = error.statusText;
        }
        ErrorHandler.addErrors(errors, css.warningErrorClass, "div", css.inputErrorClass, "div");
    },
    permissionsChanged: function (ev) {
        var $targ = $(ev.currentTarget);
        var isChecked = $targ.is(':checked');
        var $checkBoxes = this.$el.find('input[type="checkbox"]');
        if ($targ.attr('name') === 'Full') {
            if (isChecked) {
                $checkBoxes.prop('checked', true);
            }
            else {
                $checkBoxes.prop('checked', false);
            }
        }
        else if (!isChecked) {  // If removing a permission the Full / Site Admin permission will become unchecked
            this.$el.find('input[name="Full"]').prop('checked', false);
        }
    },
    initialize: function (options) {
        options = options || {};
        this.compiledTemplate = doT.template(Templates.get('editpermissionslayout'));
        this.options = options || {};
        if (options.useGatewayPermissions !== undefined && options.useGatewayPermissions === true) {
            this.standardPermissions = false;
        }
        return this;
    },
    render: function (permissions, skipReset) {
        if (this.standardPermissions === true) {
            this.viewData.dictionary = Constants.sp;
        }
        else {
            this.viewData.dictionary = Constants.gp;
        }
        this.viewData.standardPermissions = this.standardPermissions;
        this.$el.html(this.compiledTemplate(this.viewData));
        //On each render discard any tracked changes. Maybe
        if (!skipReset) {
            this.changedRights = [];
            this.lastRight = {};
        }
        if (permissions !== undefined) {
            this.setPermissions(permissions);
        }
        return this;
    },
    close: function () {
        this.unbind();
        this.remove();
    }

});